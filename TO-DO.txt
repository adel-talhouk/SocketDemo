Assignment Requirements:

"Enhance" your previous game to simulate jitter, latency, and dropped packets, and add a reliability layer to deal with these potential pitfalls. Your game must:

. Pass all checks on github
. Be able to open a window
. Have at least two players able to connect at once
--> These are the minimum requirements for the assignment to be gradable.

- Packets are occasionally "dropped," by random chance or by some algorithm. Dropped packets are registered as having been sent by the sender, but do not actually call the socket's send() function. Random delay is introduced to some packet's send time, and packets can be delivered out of order.
- Game state is sent through a reliability layer. Important data is sent through guaranteed mechanisms, while data that does not require guaranteed delivery is sent through simpler mechanisms. Important data is resilient to jitter, out-of-order delivery, and high latency.

---------------------------------------------------------------
Questions:

. TCP always resends dropped packets, and keeps a queue of things to resend so nothing arrives out of order?
. Where do the layers come into play in our previous assignment? Transport layer, Network layer, Link layer?

. For the assignment, are we combining TCP with a custom UDP solution?
. Are we replacing or Send and Receive code in our NetworkManager? Do we port over all the serialization and deserialization code to the DeliveryNotificationManager, or do we keep it and call functions from DeliveryNotificationManager in our NetworkManager?

---------------------------------------------------------------
Notes and Ideas:

. Use TransmissionData.h - make GameObject derived classes also derive from and override functions
. Use Timimg.h and .cpp
. Use InFlightPacket.h and .cpp
. Use DeliveryNotificationManager.h and .cpp
. Use AckRange.h and .cpp

--> Chapter 7 slide 14 gives a good explanation of how this can be done

. Figure out how to read and write PacketSquenceNumber, AckRange, and hasAcks in our Networker (see DeliveryNotificationManager.cpp's reads from inInputStream)

. Sync PacketSequenceNumbers on server and client!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
. Add a DeliveryNotificationManager* to Networker, handle cleanup as well
. Not sure where yet, but keep checking for timeouts on sent packets (if they did not receive acks, I think this is in DeliveryNotificationmanager), but use  get transmission data in InFlightpacket to handle success or failure on ack and on timeout
--> Investigate functions in DeliveryNotificationManager and figure out how to implement them with out stuff

-----------------------------------------------------------------

Simulating Latency/Jitter

1. Along with header, send a float for arrival time
	Note: Arrival time should be +/- a random amount, for simulating jitter

2. Insert inflightpacket into a queue (couple ways to do this)
	Note: one way the professor recommended is to enqueue the bytes recieve and split it that way (memory management yaaaaay)

3. Sort Queue based on arrival time (this will simulate jitter)

4. Each frame of the game, we process only the packets that arrvive based on the current arrival time
	Note: if arrival time = x seconds, we only process the packets x seconds ago